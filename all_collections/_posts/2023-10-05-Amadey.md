---
layout: post
title: Анализ сэмпла Amadey
date: 2023-05-10
categories: ["malware analysis", "first post"]
---
![Logo](../../images/amadey/miner_versus_amadey.jpeg)

Приветствую, дорогой читатель!

В этой статье я проанализирую реальный сэмпл вредоносного ПО семейства Amadey, который довольно популярен в последнее время.

>_**Amadey** - это ботнет, который появился примерно в октябре 2018 года и продается примерно за 500 долларов на русскоязычных хакерских форумах. Он периодически отправляет информацию о системе и установленном AV-программном обеспечении на свой сервер C2 и проводит опросы для получения команд от него. Его основная функциональность заключается в том, что он может загружать другие полезные нагрузки (называемые "задачами") для всех или специально целевых компьютеров, скомпрометированных вредоносным ПО_

По трекеру any.run он занимает топовые позиции, а именно, второе и третье место, за 7 и 365 дней соответственно.
![1](../../images/amadey/1.png)
![2](../../images/amadey/2.png)

Хеши рассматриваемого мною сэмпла следующие:

- MD5: 3046ee18ca3ecf3655b704c65c595c72
- SHA-1: e50c175ca1120e600a0728b3ae771ea9e3ecaa73
- SHA-256: d5f14b56cd42d5ef42a59c6b1140de0fd19c4f53e6bab07979b941acd30a11e0

Обозначу основные пункты статьи:

1. Извлечение payload'a
2. Анализ импорта и строк
3. Расшифровка закодированных строк
4. Анализ вызываемых API-функций
5. Получение вторичных модулей
6. Вторая попытка расшифровки строк

---

# Начало анализа - DIE

Для начала посмотрим, что перед нами, а именно - загрузим целевой файл в утилиту Detect-it-Easy:
![3](../../images/amadey/3.png)

Мы прекрасно видим, что файл является 32-разрядным исполняемым файлом. Который в данном случае на самом деле является cab-архивом. По факту, это .zip, который может быть выполнен как EXE-файл. Извлечем содержимое архива обычным 7zip'ом.
![4](../../images/amadey/4.png)

Хм, внутри еще один cab-архив и исполняемый файл. Попробуем разобраться с исполняемым файлом.
![4](../../images/amadey/4.png)

Это PE x32 файл, поэтому каким-нибудь dnSpy изучить его не получится, придется идти в IDA и иже с ней…

Будем все это дело сначала изучать в IDA Free, на момент написания статьи версия 8.2.

---

# Импорты и строки
Видим следующую картину, перед нами main-функция:
![4](../../images/amadey/4.png)

По опыту не сказал бы, что сильно заморачивались с упаковкой, да и энтропия не выше 6 на протяжении всех секций. Два создания потока и сон после них - вероятнее всего внутри функций потоков общение с С2 и получение команд. Узнаем позже, пока изучим что же творится под капотом у малвари.

Импортирует образец довольно скромный набор библиотек:

- advapi32
    
    RegSetValueExA - персистенс?
    
- kernel32
    
    CreateFileA - дропает что-то, трудяга
    
    CreateThread - уже видели
    
    CreateMutexA - зачем множить себя, не так ли?
    
    CreateProcessA - куда же без этого
    
    GetThreadContext - погодите-ка..
    
    SetThreadContext - ..очень похоже на..
    
    ResumeThread - ..внедрение кода!..
    
    ..и куча других легитимномалварных функций
    
- shell32
    
    ShellExecuteA - и что ты будешь этим запускать?
    
- wininet
    
    InternetOpen{X} и остальные - тут тоже все ясно, надо же как-то общаться с командным центром

Что ж, с импортом разобрались, даже предположили наличие инъекции кода модной техникой. А что строки? Может получится выудить С2 и заблокировать на периметре пораньше?
![4](../../images/amadey/4.png)

Какая красота! Рай для CTF-ера, сплошной Base64. Попробуем вбить одну из строк в КиберШеф, найдем и достанем конфиг и пойдем по своим более важным делам.
![4](../../images/amadey/4.png)

Что ж, неудача. Что-то кастомное. А если проследовать по x-ref'am и найти функцию которая декодит это барахло?
![4](../../images/amadey/4.png)

Ну и кому нравится С-подобный код:
![4](../../images/amadey/4.png)

Очень похоже на то, что функция 413CF0 декодирует нашу строчку.. Как часто она вызывается? 
![4](../../images/amadey/4.png)

Аж 238 раз, похоже на декодирующую функцию.

---

# Расшифровка строк с x32dbg
Лень - двигатель чего-то там. Пойдем-ка мы в дебаггер и исследуем что у этой функции на выходе происходит, а то вдруг время зря теряем.

Расчехляем x32dbg, загружаем туда наш сэмпл, жмем F9, падаем в EntryPoint, перебазируем сэмпл в IDA и ставим бряк на ret-инструкцию целевой функции и смотрим что она вернет. Успели? Сейчас помедленнее.

С загрузкой сэмпла в дебаггер трудностей возникнуть не должно. Узнаем по какому адресу расположился целевой сэмпл с помощью карты памяти:
![4](../../images/amadey/4.png)

Проставим в IDA этот базовый адрес: Edit → Segments → Rebase program…

Адрес функции поменялся, что логично:
![4](../../images/amadey/4.png)

Теперь мы целимся на D03CF0, а если быть совсем точным, то на адрес возврата из функции. Как мы можем видеть, наше перебазирование успешно. так как код идентичен:
![4](../../images/amadey/4.png)

Ставим бряк на нужном нам адресе:
![4](../../images/amadey/4.png)

Первый запуск ничего толкового не дал, какой-то набор цифр с буквами (обратите внимание на регистр ЕАХ):
![4](../../images/amadey/4.png)

Спешу вас огорчить, последующие вызовы не дали ожидаемого результата - никаких осмысленных строк мы не встретим, только перечисление вышенайденных Base64-подобных:
![4](../../images/amadey/4.png)

Что ж, эта функция не отвечает за декодирование строк, а скорее всего отвечает за копирование оных.

Давайте как-нибудь назовем эту функцию и примемся за изучение main-функционала.

---





---
### There's a horizontal rule below this.

---

### Here is an unordered list:

- Item foo
- Item bar
- Item baz
- Item zip

### And an ordered list:

1.  Item one
    1.  Item one
    1.  Item two
        1.  Item one
        1.  Item two
        1.  Item three
    1.  Item three
1.  Item four
1.  Item two
1.  Item three
1.  Item four

### And a nested list:

- level 1 item
  - level 2 item
  - level 2 item
    - level 3 item
    - level 3 item
- level 1 item
  - level 2 item
  - level 2 item
  - level 2 item
- level 1 item
  - level 2 item
  - level 2 item
- level 1 item

```
Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long.
```

```
The final element.
```
